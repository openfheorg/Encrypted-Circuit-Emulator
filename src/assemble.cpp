// @file assemble.cpp -- support assembly of intermdiate *.out file format
//==================================================================================
// BSD 2-Clause License
//
// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other
// contributors
//
// All rights reserved.
//
// Author TPOC: contact@openfhe.org
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
// this
//    list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//==================================================================================
#include "assemble.h"
#include "analyze.h"
#include <algorithm>
#include <cstring>
#include <functional>
#include <iostream>

#define ADD_IT 0 // set to 1 in order to use matlab indexing on output file

// currently works but does not compute depth.

void assemble_bristol(Analysis &analysis, unsigned int max_depth,
                      bool debug_flag) {
  //
  // Code to generate an assembler listing from a variable and function list
  // that has been generated by processing an circuit description file with
  // analyze.cpp
  //
  // List of Authors:
  //     David Bruce Cousins, currently dcousins@njit.edu
  // Description:
  //
  // assemble opcodes for Encrypted Circuit Evaluation
  // the circuit is preprocessed in to a list of nodes/variables and
  // gates/functions by the analyze() function. for every line operation in the
  // orginal input file the code maps circuit nodes (listed in var) to a list of
  // registers, the system also generates an assembly listing for that function,
  // with the appropriate input and output "gates" addeda Additionally, the code
  // keeps track of each AND, and updates a count of the depth of each variable.
  // If the count equals the max_depth, then a recrypt BOOT command is given,
  // and the depth reset.
  //
  // Input
  //   Analysis.v = variable structure from analyze()
  //   Analysis.f = function structure from analyze()
  //   max_depth = maximum depth the SHE scheme will support, set to zero
  //               to avoid bootstrapping.
  //   debug_flag = adds debug comments to code.
  // Output
  //   A file (currently the input file with _max_depth.txt or _fhe.txt
  //   concatenated) with the listing
  //
  // Version History:
  //   original matlab started 12/06/2012 by D. Cousins
  //   C++ port started 7/23/20
  // Known Issues:
  //   none

  //  generate an assembly listing for a circuit processed with analyze()

  Variable v = analysis.variables;
  Function f = analysis.functions;

  if (v.new_flag) {
    std::cout << "Have not updated assembler for new format" << std::endl;
  }
  // get the filename used, and remove any extension
  std::string fname;
  fname = std::string(v.in_fname);
  fname = fname.substr(0, fname.find("."));
  if (max_depth == 0) {
    fname = fname + "_FHE.out";
    max_depth = 10000;
  } else {
    fname = fname + "_" + std::to_string(max_depth) + ".out";
  }

  FILE *fid = fopen(fname.c_str(), "w"); // open the output file.

  std::cout << "Assembler: opening output file " << fname << " for output"
            << std::endl;

  if (fid == NULL) {
    std::cout << "error opening file.. exiting!" << std::endl;
  }

  fprintf(fid, "# Max depth %d\n", max_depth);
  fprintf(fid, "# number input1 bits %d\n", v.n_in1_bits);
  fprintf(fid, "# number input2 bits %d\n", v.n_in2_bits);
  fprintf(fid, "# number output1 bits %d\n", v.n_out1_bits);

  bool delayed_get_flag = true; // if true, delay get of all registers till end
                                // otherwise get output right after operation
                                // map of registers
  std::vector<bool> reg_active_map(v.n_tot,
                                   false); // if true then register (i) is
                                           // currently being used value false
                                           // = unused value true = used

  std::vector<int> reg_node_map(
      v.n_tot, -1); // current circuit node number stored in register (i)
                    // value == node number, -1 == no node.

  std::vector<int> out_map(v.n_out1_bits, -1); // map of the output registers.

  // (i) contains the node number of the ith output;
  std::vector<int> out_reg_map(v.n_out1_bits,
                               -1); // the ith entry contains the register
                                    // number of the ith output node

  std::vector<unsigned int> depth_counter(
      v.n_tot, 0); // keeps track of depth at each register

  std::vector<unsigned int> tower_counter(
      v.n_tot, 0); // keeps track of tower size at each register
  unsigned int max_tower_jump = 0;

  unsigned int max_depth_required = 0;

  std::cout << "Mapping input registers" << std::endl;
  ///////////////////////////////////////////////////////////////////////////
  //  map all circuit input registers
  // execute initial LOAD commands.

  unsigned int reg_counter = 0; // start count from 0

  // load all of first input's registers;
  // note this assumes the input registers are the first nodes assigned, first
  // reg 1 then reg 2.

  for (uint ix = 0; ix < v.n_in1_bits; ix++) {
    // load bit ix of register in 1.
    fprintf(fid, "R%d = LOAD(In%d,%d)\n", reg_counter + ADD_IT, 1, ix + ADD_IT);

    reg_active_map[reg_counter] = true;
    reg_node_map[reg_counter] = ix;
    tower_counter[reg_counter] = max_depth;
    if (debug_flag) {
      fprintf(fid, "# Assigned node %d to R%d\n",
              reg_node_map[reg_counter] + ADD_IT, reg_counter + ADD_IT);
    }

    reg_counter++;
  }

  // load all of second input's registers;
  for (uint ix = 0; ix < v.n_in2_bits; ix++) {
    // load bit ix of register in 2.
    fprintf(fid, "R%d = LOAD(In%d,%d)\n", reg_counter + ADD_IT, 2, ix + ADD_IT);

    reg_active_map[reg_counter] = true;
    reg_node_map[reg_counter] =
        ix + v.n_in1_bits; // see assumption of register numbering
    tower_counter[reg_counter] = max_depth;
    if (debug_flag) {
      fprintf(fid, "# Assigned node %d to R%d\n",
              reg_node_map[reg_counter] + ADD_IT, reg_counter + ADD_IT);
    }
    reg_counter++;
  }

  //  mark all output registers so we can keep track of them
  // also assumes that he output registers are the last mapped.
  size_t ii = 0;
  for (uint ix = (v.n_tot - v.n_out1_bits); ix < v.n_tot; ix++) {
    out_map[ii] =
        ix; // save node mapping for iith output nodes renumbered to start at 1
    ii++;
  }

  // keep track of max number of registers in use at each line of the program

  std::vector<unsigned int> active_reg_count(f.n_tot, 0);

  // keep track of how many bootstrap operations get called.
  unsigned int boot_counter = 0;

  //  loop over every line in the f.call_list (i.e. each boolean operation in
  // the circuit
  std::cout << "parsing functions" << std::endl;
  for (uint line_ix = 0; line_ix < f.call_list.size(); line_ix++) {
    if (line_ix % 100 == 0) {
      std::cout << "\r parsed line " << line_ix << std::flush;
    }
    // for each function
    //  find next free register for storing the output and assign the output
    // node to it
    unsigned int jx = 0;
    while (reg_active_map[jx] != false) {
      jx++;
      if (jx == v.n_tot) {
        std::cout << "ran out of register storage, fatal error! exiting."
                  << std::endl;
        exit(-1);
      }
    }

    // check for low water mark goes here to make sure we did not break
    // anything

    reg_active_map[jx] = true; // mark register as used

    /////////////////////////////////////////////////////////////////////////
    // get the node number of the output
    unsigned int current_out_node =
        f.out_list[line_ix][0]; // list is always 1 long

    // and save it
    reg_node_map[jx] = current_out_node;
    unsigned int current_out_reg =
        jx; // keep track of the current output register #

    if (debug_flag) {
      fprintf(fid, "# Assigned node %d to R%d\n", reg_node_map[jx] + ADD_IT,
              jx + ADD_IT);
    }

    /////////////////////////////////////////////////////////////////////////
    // get the node numbers of the inputs

    auto invarlist = f.in_list[line_ix]; // get input node list
    std::vector<unsigned int> invarnamelist(invarlist.size());

    for (uint jx = 0; jx < invarlist.size(); jx++) {
      // for each input in the list, find the register_node it is mapped to

      // invarnamelist should be renamed to invar_reg_node_map_index or
      // something
      auto it =
          std::find(reg_node_map.begin(), reg_node_map.end(), invarlist[jx]);

      if (it != reg_node_map.end()) {
        // std::cout << "Element " << invarlist[jx] <<" found at position : " ;
        // std::cout << std::distance(reg_node_map.begin(), it) << " (counting
        // from zero) \n" ;
        invarnamelist[jx] = std::distance(reg_node_map.begin(), it);
      } else {
        std::cout
            << "input register not found in reg_node_map! fatal error, exiting!"
            << std::endl;
        exit(-1);
      }
    }

    /////////////////////////////////////////////////////////////////////////
    //  generate the line of assembly output
    std::string name = f.call_list[line_ix]; // get func name

    unsigned int output_depth = 0;
    // different operators have different handlers
    // dispatch to the correct one
    if (name == "XOR") {
#if COMPUTE_DEPTH
      // output depth  = max (input depths)
      depth1 = depth_counter[invarnamelist[0]];
      depth2 = depth_counter[invarnamelist[1]];
      input_depth = std::max(depth1, depth2);
      output_depth = input_depth;
      depth_counter[current_out_reg] = output_depth;

      // adjust tower sizes if necessary
      // we know that if two different depths are used we need to
      // reduce the larger to the smaller before we can operate.
      // issues: how is this done. do we need new registers, and if so
      // then should we optimizez the use of these registers, or just
      // and free them for this reduction operation, placing the result
      // back in the same register.
      // for now we will just report that we need a reduction.
      if (depth1 > depth2)
        delta_depth = depth1 - depth2;
      //                 fprintf(fid,"R%d = MREDUCE(R%d,%d)  !depth = %d\n",...
      //                 current_out_reg, name, invarnamelist(1),
      //                 invarnamelist(2), output_depth);
      fprintf(fid, "reduction of %d needed on first register\n", delta_depth);
      if (delta_depth > max_tower)
        jump max_tower_jump = delta_depth;
      end elseif(depth2 > depth1) delta_depth = depth2 - depth1;
      fprintf(fid, "reduction of %d needed on second register\n", delta_depth);
      if (delta_depth > max_tower)
        _ jump max_tower_jump = delta_depth;
      end end
#else
      output_depth = 1;
#endif
          // generate listing
          fprintf(fid, "R%d = %s(R%d, R%d)  !depth = %d\n",
                  current_out_reg + ADD_IT, name.c_str(),
                  invarnamelist[0] + ADD_IT, invarnamelist[1] + ADD_IT,
                  output_depth);
    } else if (name == "AND") {
#if COMPUTE_DEPTH
      // output depth  = max (input depths)+ 1
      depth1 = depth_counter(invarnamelist(1));
      depth2 = depth_counter(invarnamelist(2));
      input_depth = max(max(depth1, depth2));

      // adjust tower sizes if necessary
      if (depth1 > depth2)
        delta_depth = depth1 - depth2;
      //                 fprintf(fid,"R%d = MREDUCE(R%d,%d)  !depth = %d\n",
      //                 current_out_reg, name, invarnamelist(1),
      //                 invarnamelist(2), output_depth);
      fprintf(fid, "reduction of %d needed on first register\n", delta_depth);
      elseif(depth2 > depth1) delta_depth = depth2 - depth1;
      fprintf(fid, "reduction of %d needed on second register\n", delta_depth);
      end
          // adjust input depth
          output_depth = input_depth + 1;
#else
      output_depth = 1;
#endif
      // generate listing
      fprintf(fid, "R%d = %s(R%d, R%d) !depth = %d\n", current_out_reg + ADD_IT,
              name.c_str(), invarnamelist[0] + ADD_IT,
              invarnamelist[1] + ADD_IT, output_depth);
#if COMPUTE_DEPTH
      if (max_depth_required < output_depth) {
        max_depth_required = output_depth;
      }

      if (output_depth == max_depth) {
        // trigger a BOOTSTRAP
        // find a new output register
        // note, we do not incrememnt the register, since bootstrap
        // is only a placeholder here.  We would need to flesh this
        // out into more calls

        fprintf(fid, "R%d = BOOT(R%d) !new depth = 0\n", current_out_reg,
                current_out_reg);
        output_depth = 0;
        boot_counter = boot_counter + 1;
      }
      depth_counter[current_out_reg] = output_depth;
#endif
    } else if (name == "NOT") {
#if COMPUTE_DEPTH
      // output depth  = input depth
      input_depth = depth_counter(invarnamelist(1));
      output_depth = input_depth;
      depth_counter(current_out_reg) = output_depth;
#endif
      // generate listing
      fprintf(fid, "R%d = %s(R%d) !depth = %d\n", current_out_reg + ADD_IT,
              name.c_str(), invarnamelist[0] + ADD_IT, output_depth);

    } else {
      std::cout << "parse error on line :" << line_ix << std::endl;
      fprintf(fid, "#parse error on line %d\n", line_ix);
    }

    //  get the number of used (nonfalse) registers in the map for this line
    active_reg_count[line_ix] =
        std::count_if(reg_active_map.begin(), reg_active_map.end(),
                      [](bool c) { return c != false; });

    //  if it is a terminal output (i.e. one that gets read out of the alu
    // out_ix = find(out_map == current_out_node);

    auto it = std::find(out_map.begin(), out_map.end(), current_out_node);

    if (it != out_map.end()) {
      // std::cout << "Element " << invarlist[jx] <<" found at position : " ;
      // std::cout << std::distance(out_map.begin(), it) << " (counting from
      // zero) \n" ;

      auto out_ix = std::distance(out_map.begin(), it);

      if (!delayed_get_flag) {
        // write out the STORE command right away.
        fprintf(fid, "Out%ld = STORE(R%d) ! depth = %d\n", out_ix + ADD_IT,
                current_out_reg + ADD_IT,
                output_depth); // get the appropriate output
      } else {
        // otherwise make a commend and mark it for output at the end of
        // program
        fprintf(fid, "# R%d is a terminal output register for out%ld\n",
                current_out_reg + ADD_IT, out_ix + ADD_IT);
        out_reg_map[out_ix] = current_out_reg; // #ok
      }
    }

  } // for each line_ix in f.call_list

  //  clean up by writing outputs if necessary
  if (delayed_get_flag) {
    // get all terminal outputs
    for (uint ix = 0; ix < out_map.size(); ix++) {
      fprintf(fid, "Out%d = STORE(R%d) ! depth = %d\n", ix + ADD_IT,
              out_reg_map[ix] + ADD_IT,
              depth_counter[out_reg_map[ix]]); // get the appropriate output
    }
  }

  //  write out statistics
  fprintf(fid, "# Assembler statistics\n");
  fprintf(fid, "# max depth supported: %d\n", max_depth);
  fprintf(fid, "# max depth required: %d\n", max_depth_required);
  fprintf(fid, "# max tower jump: %d\n", max_tower_jump);
  fprintf(fid, "# %d registers used\n",
          *max_element(active_reg_count.begin(), active_reg_count.end()));
  fprintf(fid, "# %d BOOT operations required\n", boot_counter);

  //  Close output file
  fclose(fid);
}
